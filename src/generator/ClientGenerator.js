"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClientGenerator = void 0;
const path_1 = require("path");
const fs_1 = require("fs");
class ClientGenerator {
    app;
    constructor(app) {
        this.app = app;
    }
    generate(outputPath = 'client.ts') {
        const routes = this.app.router.getRoutes();
        const schemas = new Map();
        const clientMethods = [];
        const typeDefinitions = [];
        // Helper to get schema name
        const getSchemaName = (schema) => {
            return 'Schema' + Math.random().toString(36).substring(7);
        };
        clientMethods.push(`
export class ApiClient {
  constructor(private baseUrl: string = '', private fetcher: typeof fetch = fetch) {}

  private async request<T>(method: string, path: string, body?: any, headers: Record<string, string> = {}): Promise<T> {
    const response = await this.fetcher(this.baseUrl + path, {
      method,
      headers: {
        'Content-Type': 'application/json',
        ...headers,
      },
      body: body ? JSON.stringify(body) : undefined,
    });

    if (!response.ok) {
      throw new Error(\`Request failed: \${response.statusText}\`);
    }

    const contentType = response.headers.get('content-type');
    if (contentType && contentType.includes('application/json')) {
      return response.json();
    }
    return response.text() as any;
  }
`);
        // Group routes by controller/prefix
        const grouped = {};
        for (const route of routes) {
            const parts = route.path.split('/').filter(Boolean);
            const group = parts[0] || 'root';
            if (!grouped[group])
                grouped[group] = [];
            grouped[group].push(route);
        }
        for (const [group, groupRoutes] of Object.entries(grouped)) {
            clientMethods.push(`  public ${group} = {`);
            for (const route of groupRoutes) {
                const method = route.method.toLowerCase();
                // Convert path params :id to ${id}
                const pathParams = [];
                const jsPath = route.path.replace(/:(\w+)/g, (_, param) => {
                    pathParams.push(`${param}: string | number`);
                    return `\${${param}}`;
                });
                const funcName = route.method + route.path.replace(/\//g, '_').replace(/:/g, '').replace(/^_/, '') || 'index';
                let cleanFuncName = method;
                const parts = route.path.split('/').filter(Boolean);
                if (parts.length > 1 && parts[parts.length - 1].startsWith(':')) {
                    if (method === 'get')
                        cleanFuncName = 'get';
                    if (method === 'put')
                        cleanFuncName = 'update';
                    if (method === 'delete')
                        cleanFuncName = 'delete';
                }
                else {
                    if (method === 'get')
                        cleanFuncName = 'list';
                    if (method === 'post')
                        cleanFuncName = 'create';
                }
                const args = [...pathParams, ...(method !== 'get' ? ['data?: any'] : [])].join(', ');
                clientMethods.push(`    ${cleanFuncName}: (${args}) => this.request('${route.method}', \`${jsPath}\` ${method !== 'get' ? ', data' : ''}),`);
            }
            clientMethods.push(`  };`);
        }
        clientMethods.push('}');
        // ==========================================
        // WebSocket Client
        // ==========================================
        clientMethods.push(`
export class WsClient {
  private socket: WebSocket | null = null;
  private messageHandlers: Map<string, (data: any) => void> = new Map();

  constructor(private url: string) {}

  connect() {
    this.socket = new WebSocket(this.url);
    this.socket.onmessage = (event) => {
      try {
        const payload = JSON.parse(event.data as string);
        if (payload.event && this.messageHandlers.has(payload.event)) {
          this.messageHandlers.get(payload.event)!(payload.data);
        }
      } catch (e) {}
    };
  }

  on(event: string, callback: (data: any) => void) {
    this.messageHandlers.set(event, callback);
  }

  emit(event: string, data: any) {
    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
      this.socket.send(JSON.stringify({ event, data }));
    } else {
      console.warn('WebSocket is not connected');
    }
  }
}
`);
        const output = `/**
 * CanxJS Auto-Generated Client
 * 
 * Do not edit this file manually.
 */

${clientMethods.join('\n')}

export const api = new ApiClient();
`;
        (0, fs_1.writeFileSync)((0, path_1.join)(process.cwd(), outputPath), output);
        console.log(`[ClientGenerator] Generated client SDK at ${outputPath}`);
    }
}
exports.ClientGenerator = ClientGenerator;
