import { join } from 'path';
import { writeFileSync } from 'fs';
import type { Canx } from '../Application';
import { Schema } from '../schema/Schema';

export class ClientGenerator {
  constructor(private app: Canx) {}

  generate(outputPath: string = 'client.ts'): void {
    const routes = this.app.router.getRoutes();
    const schemas = new Map<string, string>();
    const clientMethods: string[] = [];
    const typeDefinitions: string[] = [];

    // Helper to get schema name
    const getSchemaName = (schema: any): string => {
        return 'Schema' + Math.random().toString(36).substring(7);
    };

    clientMethods.push(`
export class ApiClient {
  constructor(private baseUrl: string = '', private fetcher: typeof fetch = fetch) {}

  private async request<T>(method: string, path: string, body?: any, headers: Record<string, string> = {}): Promise<T> {
    const response = await this.fetcher(this.baseUrl + path, {
      method,
      headers: {
        'Content-Type': 'application/json',
        ...headers,
      },
      body: body ? JSON.stringify(body) : undefined,
    });

    if (!response.ok) {
      throw new Error(\`Request failed: \${response.statusText}\`);
    }

    const contentType = response.headers.get('content-type');
    if (contentType && contentType.includes('application/json')) {
      return response.json();
    }
    return response.text() as any;
  }
`);

    // Group routes by controller/prefix
    const grouped: Record<string, any[]> = {};
    
    for (const route of routes) {
      const parts = route.path.split('/').filter(Boolean);
      const group = parts[0] || 'root';
      if (!grouped[group]) grouped[group] = [];
      grouped[group].push(route);
    }

    for (const [group, groupRoutes] of Object.entries(grouped)) {
         clientMethods.push(`  public ${group} = {`);
         
         for (const route of groupRoutes) {
             const method = route.method.toLowerCase();
             
             // Convert path params :id to ${id}
             const pathParams: string[] = [];
             const jsPath = route.path.replace(/:(\w+)/g, (_: string, param: string) => {
                 pathParams.push(`${param}: string | number`);
                 return `\${${param}}`;
             });

             const funcName = route.method + route.path.replace(/\//g, '_').replace(/:/g, '').replace(/^_/, '') || 'index';
             
             let cleanFuncName = method;
             const parts = route.path.split('/').filter(Boolean);
             if (parts.length > 1 && parts[parts.length-1].startsWith(':')) {
                 if (method === 'get') cleanFuncName = 'get';
                 if (method === 'put') cleanFuncName = 'update';
                 if (method === 'delete') cleanFuncName = 'delete';
             } else {
                 if (method === 'get') cleanFuncName = 'list';
                 if (method === 'post') cleanFuncName = 'create';
             }

             const args = [...pathParams, ...(method !== 'get' ? ['data?: any'] : [])].join(', ');
             
             clientMethods.push(`    ${cleanFuncName}: (${args}) => this.request('${route.method}', \`${jsPath}\` ${method !== 'get' ? ', data' : ''}),`);
         }

         clientMethods.push(`  };`);
    }

    clientMethods.push('}');

    // ==========================================
    // WebSocket Client
    // ==========================================
    clientMethods.push(`
export class WsClient {
  private socket: WebSocket | null = null;
  private messageHandlers: Map<string, (data: any) => void> = new Map();

  constructor(private url: string) {}

  connect() {
    this.socket = new WebSocket(this.url);
    this.socket.onmessage = (event) => {
      try {
        const payload = JSON.parse(event.data as string);
        if (payload.event && this.messageHandlers.has(payload.event)) {
          this.messageHandlers.get(payload.event)!(payload.data);
        }
      } catch (e) {}
    };
  }

  on(event: string, callback: (data: any) => void) {
    this.messageHandlers.set(event, callback);
  }

  emit(event: string, data: any) {
    if (this.socket && this.socket.readyState === WebSocket.OPEN) {
      this.socket.send(JSON.stringify({ event, data }));
    } else {
      console.warn('WebSocket is not connected');
    }
  }
}
`);

    const output = `/**
 * CanxJS Auto-Generated Client
 * 
 * Do not edit this file manually.
 */

${clientMethods.join('\n')}

export const api = new ApiClient();
`;

    writeFileSync(join(process.cwd(), outputPath), output);
    console.log(`[ClientGenerator] Generated client SDK at ${outputPath}`);
  }
}
