import { join } from 'path';
import { writeFileSync } from 'fs';
import type { Canx } from '../Application';
import { Schema } from '../schema/Schema';

export class ClientGenerator {
  constructor(private app: Canx) {}

  generate(outputPath: string = 'client.ts'): void {
    const routes = this.app.router.getRoutes();
    const schemas = new Map<string, string>();
    const clientMethods: string[] = [];
    const typeDefinitions: string[] = [];

    // Helper to get schema name
    const getSchemaName = (schema: any): string => {
        // This is a simplification. In a real scenario we might need better schema naming strategies
        // or allow users to name their schemas.
        // For now, we will try to generate a hash or use a description if available.
        return 'Schema' + Math.random().toString(36).substring(7);
    };

    clientMethods.push(`
export class ApiClient {
  constructor(private baseUrl: string = '', private fetcher: typeof fetch = fetch) {}

  private async request<T>(method: string, path: string, body?: any, headers: Record<string, string> = {}): Promise<T> {
    const response = await this.fetcher(this.baseUrl + path, {
      method,
      headers: {
        'Content-Type': 'application/json',
        ...headers,
      },
      body: body ? JSON.stringify(body) : undefined,
    });

    if (!response.ok) {
      throw new Error(\`Request failed: \${response.statusText}\`);
    }

    const contentType = response.headers.get('content-type');
    if (contentType && contentType.includes('application/json')) {
      return response.json();
    }
    return response.text() as any;
  }
`);

    // Group routes by controller/prefix
    const grouped: Record<string, any[]> = {};
    
    for (const route of routes) {
      const parts = route.path.split('/').filter(Boolean);
      const group = parts[0] || 'root';
      if (!grouped[group]) grouped[group] = [];
      grouped[group].push(route);
    }

    for (const [group, groupRoutes] of Object.entries(grouped)) {
         clientMethods.push(`  public ${group} = {`);
         
         for (const route of groupRoutes) {
             const method = route.method.toLowerCase();
             
             // Convert path params :id to ${id}
             const pathParams: string[] = [];
             const jsPath = route.path.replace(/:(\w+)/g, (_: string, param: string) => {
                 pathParams.push(`${param}: string | number`);
                 return `\${${param}}`;
             });

             const funcName = route.method + route.path.replace(/\//g, '_').replace(/:/g, '').replace(/^_/, '') || 'index';
             // Clean up funcName (e.g. get_users_id -> getById in users scope ideally, but let's keep it simple first)
             // Simple mapping: 
             // GET /users -> list
             // GET /users/:id -> get
             // POST /users -> create
             // PUT /users/:id -> update
             // DELETE /users/:id -> delete
             
             let cleanFuncName = method;
             const parts = route.path.split('/').filter(Boolean);
             if (parts.length > 1 && parts[parts.length-1].startsWith(':')) {
                 if (method === 'get') cleanFuncName = 'get';
                 if (method === 'put') cleanFuncName = 'update';
                 if (method === 'delete') cleanFuncName = 'delete';
             } else {
                 if (method === 'get') cleanFuncName = 'list';
                 if (method === 'post') cleanFuncName = 'create';
             }

             // Check if route has body validation schema attached (we'd need to store this meta in route first)
             // For now, allow 'data: any'
             const args = [...pathParams, ...(method !== 'get' ? ['data?: any'] : [])].join(', ');
             
             clientMethods.push(`    ${cleanFuncName}: (${args}) => this.request('${route.method}', \`${jsPath}\` ${method !== 'get' ? ', data' : ''}),`);
         }

         clientMethods.push(`  };`);
    }

    clientMethods.push(`}`);

    const output = `/**
 * CanxJS Auto-Generated Client
 * 
 * Do not edit this file manually.
 */

${clientMethods.join('\n')}

export const api = new ApiClient();
`;

    writeFileSync(join(process.cwd(), outputPath), output);
    console.log(`[ClientGenerator] Generated client SDK at ${outputPath}`);
  }
}
